export const dynamic = 'force-dynamic';

import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
const pdfParse = require('pdf-parse');

// Helper function to extract text from PDF
async function extractTextFromPDF(buffer: Buffer): Promise<string> {
  console.log('ðŸ“„ [upload-entrees] DÃ©but de l\'extraction du PDF avec pdf-parse');
  
  try {
    const data = await pdfParse(buffer);
    const text = data.text || '';
    
    console.log(`ðŸ“„ [upload-entrees] PDF extrait: ${text.length} caractÃ¨res, ${data.numpages} pages`);
    console.log('ðŸ“„ [upload-entrees] AperÃ§u du texte (premiers 1000 chars):');
    console.log(text.substring(0, 1000));
    console.log('---');
    
    return text;
  } catch (error) {
    console.error('ðŸ“„ [upload-entrees] Erreur lors de l\'extraction du PDF:', error);
    return '';
  }
}

// Fonction pour nettoyer le texte
function cleanText(text: string): string {
  if (!text) return '';
  return text
    .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '')
    .replace(/\s+/g, ' ')
    .trim();
}

// Fonction pour parser le texte extrait
function parseExtractedText(text: string): any[] {
  console.log('ðŸ“„ [upload-entrees] === DÃ‰BUT PARSING ===');
  const entries: any[] = [];
  
  if (!text || text.length < 10) {
    console.log('ðŸ“„ [upload-entrees] âŒ Pas de texte valide Ã  parser!');
    return entries;
  }
  
  // Nettoyer le texte
  const cleanedText = text
    .replace(/\r\n/g, ' ')
    .replace(/\n/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
  
  console.log('ðŸ“„ [upload-entrees] Texte nettoyÃ© (premiers 500 chars):');
  console.log(cleanedText.substring(0, 500));
  
  // Pattern 1: DESCRIPTION DATE QTE QTE2 PRIX TOTAL
  // Format: PAUSE DEJEUNER 12/05/25 1 19 5000 95000
  const pattern1 = /([A-Za-zÃ€-Ã¿\s]+?)\s+(\d{1,2}\/\d{1,2}\/\d{2,4})\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)/g;
  
  console.log('ðŸ“„ [upload-entrees] Recherche Pattern 1 (avec DATE + 4 nombres)...');
  let match;
  
  while ((match = pattern1.exec(cleanedText)) !== null) {
    const description = cleanText(match[1]).trim();
    const date = match[2];
    const num1 = parseInt(match[3], 10);
    const num2 = parseInt(match[4], 10);
    const num3 = parseInt(match[5], 10);
    const num4 = parseInt(match[6], 10);
    
    console.log(`ðŸ“„ [upload-entrees] TrouvÃ©: "${description}" | ${date} | ${num1} ${num2} ${num3} ${num4}`);
    
    const qte = num2;
    const prixUnitaire = num3;
    const totalHT = num4;
    
    if (qte < 1 || qte > 1000 || prixUnitaire < 100 || totalHT < 100) {
      console.log(`ðŸ“„ [upload-entrees]   âŒ IGNORÃ‰E (valeurs non valides)`);
      continue;
    }
    
    const entry = {
      date: new Date(),
      description: description.substring(0, 255),
      montant: totalHT,
      qte,
      prixUnitaire,
      totalHT,
    };
    
    entries.push(entry);
    console.log(`ðŸ“„ [upload-entrees]   âœ… ACCEPTÃ‰E: QTE=${qte}, PU=${prixUnitaire}, TOTAL=${totalHT}`);
  }
  
  // Pattern 2: DESCRIPTION DATE QTE PRIX TOTAL (3 nombres)
  if (entries.length === 0) {
    console.log(`ðŸ“„ [upload-entrees] Pattern 1 trouvÃ© 0. Essai Pattern 2...`);
    const pattern2 = /([A-Za-zÃ€-Ã¿\s]+?)\s+(\d{1,2}\/\d{1,2}\/\d{2,4})\s+(\d+)\s+(\d+)\s+(\d+)/g;
    
    while ((match = pattern2.exec(cleanedText)) !== null) {
      const description = cleanText(match[1]).trim();
      const date = match[2];
      const qte = parseInt(match[3], 10);
      const prixUnitaire = parseInt(match[4], 10);
      const totalHT = parseInt(match[5], 10);
      
      console.log(`ðŸ“„ [upload-entrees] Pattern 2 trouvÃ©: "${description}"`);
      
      if (qte < 1 || qte > 1000 || prixUnitaire < 100 || totalHT < 100) {
        console.log(`ðŸ“„ [upload-entrees]   âŒ IGNORÃ‰E (valeurs non valides)`);
        continue;
      }
      
      const entry = {
        date: new Date(),
        description: description.substring(0, 255),
        montant: totalHT,
        qte,
        prixUnitaire,
        totalHT,
      };
      
      entries.push(entry);
      console.log(`ðŸ“„ [upload-entrees]   âœ… ACCEPTÃ‰E`);
    }
  }
  
  console.log(`ðŸ“„ [upload-entrees] === FIN PARSING === Total: ${entries.length} entrÃ©es trouvÃ©es`);
  return entries;
}

export async function GET() {
  return NextResponse.json({ error: "Route dÃ©sactivÃ©e" }, { status: 410 });
}

export async function POST(
  request: NextRequest,
  { params }: { params: { clientId: string } }
) {
  try {
    console.log("ðŸ“„ [upload-entrees] Starting upload for client:", params.clientId);

    const formData = await request.formData();
    const file = formData.get("entreesFile") as File;

    if (!file) {
      console.error("ðŸ“„ [upload-entrees] No file provided");
      return NextResponse.json(
        { error: "Aucun fichier fourni" },
        { status: 400 }
      );
    }

    if (!file.type.includes("pdf")) {
      console.error("ðŸ“„ [upload-entrees] Invalid file type:", file.type);
      return NextResponse.json(
        { error: "Le fichier doit Ãªtre au format PDF" },
        { status: 400 }
      );
    }

    const buffer = Buffer.from(await file.arrayBuffer());
    console.log("ðŸ“„ [upload-entrees] File read successfully, size:", buffer.length, "bytes");

    // Extraire le texte du PDF
    const extractedText = await extractTextFromPDF(buffer);
    const entries = parseExtractedText(extractedText);
    console.log(`ðŸ“„ [upload-entrees] AprÃ¨s parsing: ${entries.length} entrÃ©es trouvÃ©es`);
    
    // TEST: Si 0 entrÃ©es trouvÃ©es
    if (entries.length === 0) {
      console.log("ðŸ“„ [upload-entrees] âš ï¸  Aucune entrÃ©e trouvÃ©e!");
      entries.push({
        date: new Date(),
        description: "EntrÃ©e test - PDF non parsÃ© correctement",
        montant: 50000
      });
    }

    // Enregistrer en base
    const now = new Date();
    const year = now.getFullYear();
    const createdEntries = [];
    let entreesCreated = 0;
    const errors: string[] = [];
    
    try {
      let dossier = await prisma.dossierComptable.findFirst({
        where: {
          clientId: params.clientId,
          mois: now.getMonth() + 1,
          annee: year,
        },
      });

      if (!dossier) {
        dossier = await prisma.dossierComptable.create({
          data: {
            clientId: params.clientId,
            mois: now.getMonth() + 1,
            annee: year,
            dateCreation: now,
            statut: "EN_COURS",
          },
        });
        console.log("ðŸ“„ [upload-entrees] Created dossier comptable:", dossier.id);
      }

      for (let i = 0; i < entries.length; i++) {
        try {
          const entry = entries[i];
          const montant = entry.montant || 0;
          let description = entry.description || "EntrÃ©e sans description";
          
          description = cleanText(description);

          if (montant <= 0) {
            console.log("ðŸ“„ [upload-entrees] Skipping entry", i + 1, "- montant invalide");
            continue;
          }

          const createdEntry = await prisma.entreeClient.create({
            data: {
              clientId: params.clientId,
              dossierComptableId: dossier.id,
              date: entry.date || new Date(),
              description: description,
              montant: montant,
              categorie: "VENTES_PRODUITS",
              notes: `ImportÃ©e depuis PDF: ${cleanText(file.name)}`,
            },
          });

          createdEntries.push({
            date: createdEntry.date.toISOString(),
            description: createdEntry.description,
            montant: createdEntry.montant,
            qte: entry.qte,
            prixUnitaire: entry.prixUnitaire,
            totalHT: entry.totalHT,
          });
          
          entreesCreated++;
          console.log("ðŸ“„ [upload-entrees] Entry created:", description, "-", montant, "XAF");
        } catch (error) {
          const errorMsg = error instanceof Error ? error.message : "Erreur inconnue";
          console.error("ðŸ“„ [upload-entrees] Error creating entry", i + 1, ":", errorMsg);
          errors.push(`EntrÃ©e ${i + 1}: ${errorMsg}`);
        }
      }

      console.log("ðŸ“„ [upload-entrees] Upload complete. EntrÃ©es:", entreesCreated);

      return NextResponse.json(
        {
          success: true,
          message: `${entreesCreated} entrÃ©e(s) crÃ©Ã©e(s)`,
          entreesCreated,
          totalCreated: entreesCreated,
          dossierId: dossier.id,
          entries: createdEntries,
          errors: errors.length > 0 ? errors : undefined,
        },
        { status: 200 }
      );
    } catch (error) {
      console.error("[POST /api/clients/[clientId]/upload-entrees]", error);
      return NextResponse.json(
        {
          success: false,
          message: "Erreur serveur lors du traitement du PDF",
          errors: [error instanceof Error ? error.message : "Erreur inconnue"],
        },
        { status: 500 }
      );
    }
  } catch (error) {
    console.error("[POST /api/clients/[clientId]/upload-entrees] Unexpected error:", error);
    return NextResponse.json(
      {
        success: false,
        message: "Erreur inattendue lors du traitement de la requÃªte",
        errors: [error instanceof Error ? error.message : "Erreur inconnue"],
      },
      { status: 500 }
    );
  }
}
